#!/usr/bin/env python
# -*- coding: utf-8 -*-

# ------------------------------------------------------------------------------
# 
# Author: Gabriele Girelli
# Email: gigi.ga90@gmail.com
# Version: 1.0.0
# Date: 20170718
# Project: GPSeq
# Description: Calculate radial position of dots in cells
# 
# ------------------------------------------------------------------------------



# DEPENDENCIES =================================================================

import argparse
import math
import numpy as np
import os
import pandas as pd
import pygpseq as gp
from scipy.ndimage.morphology import distance_transform_edt
import skimage.io as io
from skimage.measure import label

# PARAMETERS ===================================================================

# Add script description
parser = argparse.ArgumentParser(
	description = 'Calculate radial position of dots in cells.'
)

# Add mandatory arguments
parser.add_argument('dotCoords', type = str, nargs = 1,
	help = 'Dot coordinates table generated by DOTTER.')
parser.add_argument('imgFolder', type = str, nargs = 1,
	help = 'Folder with tiff images.')
parser.add_argument('output', type = str, nargs = 1,
	help = 'Output tsv table.')

# Optional parameters
parser.add_argument('-a', '--aspect', type = float, nargs = 3,
	help = """Physical size of Z, Y and X voxel sides.
	Default: 300.0 216.6 216.6""",
	metavar = ('Z', 'Y', 'X'), default = [300., 216.6, 216.6])

# Parse arguments
args = parser.parse_args()

# Assign to in-script variables
dot_table_name = args.dotCoords[0]
imdir = args.imgFolder[0]
aspect = args.aspect
(az, ay, ax) = aspect
outpath = args.output[0]

# FUNCTIONS ====================================================================

# RUN ==========================================================================

# Read table
t = pd.read_csv(dot_table_name, '\t')
t['cell_ID'] = np.zeros(len(t.index))
t['lamin_dist'] = np.zeros(len(t.index))
t['lamin_dist_norm'] = np.zeros(len(t.index))
t['centr_dist'] = np.zeros(len(t.index))
t['centr_dist_norm'] = np.zeros(len(t.index))

# Extract FoV number
t['File'] = [int(f.split('/')[-1].split('.')[0]) for f in t['File']]

# Identify tiff images
flist = []
for (dirpath, dirnames, filenames) in os.walk(imdir):
    flist.extend(filenames)
    break
imlist = [f for f in flist if 'tif' in f]

# Assign field of views to images
imfov = {}
for i in set(t['File']):
	imfov[i] = [im for im in imlist if "%03d" % (i,) in im][0]

# Cycle through
for ii in range(len(imfov.keys())):
	(idx, impath) = imfov.items()[ii]
	subt_idx = np.where(t['File'] == idx)[0]

	# Read image
	print("  Â· Reading '%s'..." % (impath,))
	im = io.imread(os.path.join(imdir, impath))[0]

	# Pick first timeframe
	if 3 == len(im.shape) and 1 == im.shape[0]:
		im = im[0]

	# Binarize images
	print("   - Binarizing...")
	binarization = gp.tools.binarize.Binarize(
		an_type=gp.const.AN_3D,
		seg_type=gp.const.SEG_3D
	)
	(imbin, thr, log) = binarization.run(im)

	# Calculate distance from lamina
	print("   - Analysis...")
	print("    > Calculating lamina distance...")

	# Add empty top/bottom slides
	imbin_tops = np.zeros((imbin.shape[0]+2, imbin.shape[1], imbin.shape[2]))
	imbin_tops[1:(imbin.shape[0]+1),:,:] = imbin

	# Extract cell ID
	print("    > Assigning dots to cells...")
	L = label(imbin_tops)[1:(imbin.shape[0]+1),:,:]
	t.loc[subt_idx, 'cell_ID'] = L[t['z'], t['x'], t['y']][subt_idx]

	# Calculate distance and store it
	print("    > Calculating distances...")
	D = distance_transform_edt(imbin_tops, aspect)[1:(imbin.shape[0]+1),:,:]
	t.loc[subt_idx, 'lamin_dist'] = D[t['z'], t['x'], t['y']][subt_idx]

	# Retrieve max lamin dist per cell
	cell_max_lamin_dist = {}
	for cellID in set(t.loc[subt_idx, 'cell_ID'].tolist()):
		cell_max_lamin_dist[cellID] = np.max(
			D[np.where(L == cellID)])

	# Normalize lamin_dist
	fnorm = [cell_max_lamin_dist[cellID] for cellID in t.loc[subt_idx, 'cell_ID'].tolist()]
	t.loc[subt_idx, 'lamin_dist_norm'] = t.loc[subt_idx, 'lamin_dist'] / fnorm

	# Normalized centr_dist
	t.loc[subt_idx, 'centr_dist_norm'] = 1 - t.loc[subt_idx, 'lamin_dist_norm']

	# Calculate centr_dist
	t.loc[subt_idx, 'centr_dist'] = t.loc[subt_idx, 'centr_dist_norm'] * fnorm

# Write output
t.to_csv(outpath, sep = '\t', index = False)

# END ==========================================================================

################################################################################
